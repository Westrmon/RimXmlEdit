using Microsoft.Extensions.Logging;using Microsoft.Extensions.Options;using RimXmlEdit.Core.Entries;using RimXmlEdit.Core.Extensions;using RimXmlEdit.Core.Parse;using RimXmlEdit.Core.Utils;using RimXmlEdit.Core.ValueValid;namespace RimXmlEdit.Core;/// <summary>///     此处主要是为了获取 <see cref="RXStruct" /> 的各类信息而提供的工具集合类/// </summary>public class NodeInfoManager{    private readonly HashSet<string> _loadedDlls = new();    private readonly ILogger _log;    private readonly DefParser _parser;    private readonly AppSettings _setting;    private readonly ValidatorManager _validatorManager;    private Dictionary<string, DefInfo> _defInfoDict = new();    private bool _isInited;    public NodeInfoManager(IOptions<AppSettings> options)    {        _log = this.Log();        _parser = new DefParser();        _validatorManager = new ValidatorManager();        _setting = options?.Value;    }    public DefCache DataCache { get; private set; }    public IEnumerable<string> LoadedDlls => _loadedDlls;    // 暂时使用硬编码, 若模组内容中含有此项较多考虑反射获取    public static IEnumerable<string> PatchesClassEnums => new List<string>    {        "PatchOperationAdd", "PatchOperationRemove", "PatchOperationReplace",        "PatchOperationInsert", "PatchOperationSequence", "PatchOperationSetName",        "PatchOperationAttributeAdd", "PatchOperationAttributeSet", "PatchOperationAttributeRemove",        "PatchOperationFindMod", "PatchOperationConditional"    };    public void Init()    {        if (_isInited) return;        _parser.Init();        DataCache = _parser.Parse();        _defInfoDict = DataCache.DefInfos.ToDictionary(info => info.TagName, info => info);        if (_setting is { AutoLoadDllDependencies: true })            // path后续可以通过解析模组id来自动导航到指定的目录下            foreach (var dll in _setting.CurrentProject.DependentPaths)                LoadDllDependencies(dll);        _isInited = true;    }    // 对于其他dll模组, 则需要在def上加上命名空间的前缀    public void AddDll(string dllPath)    {        LoadDllDependencies(dllPath);    }    private void LoadDllDependencies(string dllPath)    {        if (!_loadedDlls.Add(dllPath))            return;        if (!_parser.Init(dllPath))        {            _log.LogWarning("Unable to load {} dll file", Path.GetFileNameWithoutExtension(dllPath));            return;        }        var infos = _parser.Parse(setPrefixDef: true);        DataCache.MergeWith(infos);        _defInfoDict = DataCache.DefInfos.ToDictionary(info => info.TagName, info => info);    }    public IEnumerable<string> GetRootList(bool isPatches = false)    {        return isPatches ? ["Operation"] : _defInfoDict.Keys;    }    /// <summary>    ///     获取子节点列表    /// </summary>    /// <param name="name"> 节点所在的xpath路径 </param>    /// <returns> </returns>    public IEnumerable<XmlFieldInfo> GetChildList(string name)    {        var path = GetParsePath(name);        return GetChildList(path).Item2;    }    /// <summary>    ///     获取子节点名称或枚举值    /// </summary>    /// <param name="name"> 节点所在的xpath路径 </param>    /// <returns> </returns>    public IEnumerable<string> GetChildNameOrEnumValues(string name)    {        var path = GetParsePath(name);        var (node, child) = GetChildList(path);        if ((node?.Type & XmlFieldType.PolymorphicList) is XmlFieldType.PolymorphicList)            return DataCache.Comps.Where(t => t.IsThingComp).Select(g => g.FullName);        // 无论有没有子项, 都可能是枚举(DefOf)        if (node != null && node.FieldTypeName.StartsWith("List", StringComparison.OrdinalIgnoreCase))        {            var type = node.FieldTypeName[5..^1];            if (DataCache.DefCasts.TryGetValue(type, out var value)                && DataCache.DefOfEnums.TryGetValue(value, out var info))                return info;            if (name.EndsWith("li"))                return node.ResolveChildren(DataCache.Schemas).Select(t => t.Name);            return ["li"];        }        List<string>? result;        // 暂时只对Def有嵌套处理        var fieldInfos = child as XmlFieldInfo[] ?? child.ToArray();        if (fieldInfos.FirstOrDefault(t => t.FieldTypeName == "Verse.Def") is { } baseInfo)        {            result = fieldInfos.Where(t => t != baseInfo).Select(t => t.Name).ToList();            result.AddRange(GetRootList());        }        else        {            result = fieldInfos.Where(t => t.Name != "compClass").Select(t => t.Name).ToList();        }        if (result == null || result.Count == 0)            _log.LogNotify("No child nodes found for this node");        return result ?? Enumerable.Empty<string>();    }    /// <summary>    ///     保守判断某个节点的值是否合法, 值类型未知则返回true    /// </summary>    /// <param name="name"> 节点所在的xpath路径 </param>    /// <param name="value"> 使用的值 </param>    /// <returns> 是否合法 </returns>    public CheckResult CheckValueIsValid(string name, string value)    {        if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(name))            return new CheckResult(false, "Empty value or name");        if (ValueValidIgnored.IsIgnored(name)) return CheckResult.Empty;        var path = GetParsePath(name);        var field = GetDeepestAccessibleField(path);        // 没有发现节点, 可能是没有导入dll, 不必提醒        if (field == null) return CheckResult.Empty;        // 如果是defof, 那么直接获取所有枚举, 转化到附属节点下面        if (!field.Type.HasFlag(XmlFieldType.Enumable)            && DataCache.DefOfEnums.TryGetValue(field.FieldTypeName, out var info))        {            field.Type |= XmlFieldType.Enumable;            field.EnumValues = info.ToList();        }        value = value.Replace(" ", "");        if (ValueValidIgnored.IsIgnored(value)) return CheckResult.Empty;        foreach (var validator in _validatorManager.ValueValids)        {            var result = validator.IsValid(field, value);            if (result.IsEqual(CheckResult.Success)) return result;            if (!result.IsValid) return result;        }        return CheckResult.Empty;    }    private (XmlFieldInfo?, IEnumerable<XmlFieldInfo>) GetChildList(string[] path)    {        if (path.Length == 1)            return _defInfoDict.TryGetValue(path[0], out var defInfo)                ? (null, defInfo.Fields)                : (null, Enumerable.Empty<XmlFieldInfo>());        var field = GetDeepestAccessibleField(path);        if (field == null) return (null, Enumerable.Empty<XmlFieldInfo>());        if (field.Type.HasFlag(XmlFieldType.SimpleClass))        {            var fields = field.ResolveChildren(DataCache.Schemas);            return fields == null ? (field, Enumerable.Empty<XmlFieldInfo>()) : (field, fields);        }        var tags = path[^1].Split('#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);        if (tags.Length > 1)        {            var compLi = DataCache.Comps.FirstOrDefault(t => t.FullName == tags[1]);            return (null, compLi?.Fields ?? Enumerable.Empty<XmlFieldInfo>());        }        _log.LogInformation("Node \"{}\" has no child nodes", field?.Name);        return (field, Enumerable.Empty<XmlFieldInfo>());    }    private string[] GetParsePath(string originPath)    {        var path = originPath.Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);        // 只返回最后Def节点开始的片段        for (var i = path.Length - 1; i > 0; i--)            if (_defInfoDict.ContainsKey(path[i]))                return path[i..];        return path;    }    public DefInfo? GetNodeByDefName(string defName)    {        foreach (var defInfo in DataCache.DefInfos)        {            var field = defInfo.Fields.FirstOrDefault(t => t.Name == "defName");            if (field is { Value: string value } && value == defName)                return defInfo;        }        return null;    }    /// <summary>    ///     获取路径中最后一个可访问的有效节点（尽力查找）    /// </summary>    internal XmlFieldInfo? GetDeepestAccessibleField(string[] path)    {        // 后续增加缓存        if (path.Length == 0) return null;        // 一般根没有Classes属性        if (!_defInfoDict.TryGetValue(UpperInitial(path[0]), out var defInfo))        {            _log.LogDebug("Definition \"{DefName}\" cannot be found. It may be from a missing community mod.", path[0]);            return null;        }        if (path.Length == 1) return null;        var currentFields = defInfo.Fields;        XmlFieldInfo? lastValidNode = null;        for (var i = 1; i < path.Length; i++)        {            var currentPathName =                path[i].Split('#', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)[0];            // 跳过li, 继续找, 应该不影响, li'只代表此处为list            if (currentPathName == "li")                continue;            var matchedField =                currentFields?.FirstOrDefault(t => t.Name.Equals(currentPathName, StringComparison.OrdinalIgnoreCase));            if (matchedField == null)            {                _log.LogDebug("Sub-node \"{Node}\" not found under \"{Parent}\". Returning last valid parent.",                    currentPathName, path[i - 1]);                return lastValidNode;            }            lastValidNode = matchedField;            // 已经获取最后一个节点, 不需要再获取此节点的子节点            if (matchedField.Name.Equals(path[^1], StringComparison.OrdinalIgnoreCase))                break;            if (matchedField.Type.HasFlag(XmlFieldType.SimpleClass))            {                currentFields = matchedField.ResolveChildren(DataCache.Schemas);            }            else if (matchedField.Type.HasFlag(XmlFieldType.PolymorphicList))            {                var compName = path[i + 1].Split('.', StringSplitOptions.RemoveEmptyEntries).Last();                // .Replace("Properties_", "");                // if (compName.StartsWith("Comps"))                //     compName = $"CompsProperties_{compName.Substring(4)}";                var comp = DataCache.Comps.FirstOrDefault(f =>                    f.FullName.Equals(compName, StringComparison.OrdinalIgnoreCase));                if (comp == null) continue;                currentFields = comp.Fields;                i++;            }            else            {                return matchedField;            }        }        return lastValidNode;    }    private static string UpperInitial(string s)    {        if (s[0] <= 'Z') return s;        return s[..1].ToUpper() + s[1..];    }    public struct CheckResult    {        public bool IsValid;        public string ValueTypeOrErrMs;        public static CheckResult Empty => new(true, null);        public static CheckResult Success => new(true, "Ok");        public CheckResult(bool isValid, string recommendType)        {            IsValid = isValid;            ValueTypeOrErrMs = recommendType;        }        public override string ToString()        {            return "IsValid:" + IsValid + " ValueTypeOrErrMs:" + ValueTypeOrErrMs;        }        public bool IsEqual(CheckResult other)        {            return IsValid == other.IsValid && ValueTypeOrErrMs == other.ValueTypeOrErrMs;        }    }}